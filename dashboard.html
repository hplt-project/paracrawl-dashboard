<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<title>Paracrawl dashboard</title>
		<style>
			html {
				--background-color: #fff;
				--text-color: #000;
			}

			@media (prefers-color-scheme: dark) {
				html {
					--background-color: #000;
					--text-color: #ccc;
				}	
			}

			body {
				font:  14px/18px sans-serif;
				margin-bottom: 2em;
				background: var(--background-color);
				color: var(--text-color);
			}

			*[hidden] {
				display: none !important;
			}

			#job-grid	{
				width: 100%;
				table-layout: fixed;
			}

			#job-grid .job {
				display: block;
				text-decoration: none;
				padding: 0 0.25em;
				margin: 0.125em 0;
				color: rgba(255, 255, 255, 0.8);
				background: rgba(0, 0, 0, 0.5);
			}

			#job-grid .job:hover {
				text-decoration: underline;
			}

			#job-grid .job.completed,
			#job-grid .progress-bar .completed {
				background: #0a0;
			}

			#job-grid .job.pending,
			#job-grid .progress-bar .pending {
				background: #3cf;
			}

			#job-grid .job.running,
			#job-grid .progress-bar .running {
				background: #fc0;
			}

			#job-grid .job.cancelled,
			#job-grid .progress-bar .cancelled {
				background: #333;
			}

			#job-grid .job.failed,
			#job-grid .progress-bar .failed {
				background: #c33;
			}

			#job-grid .job.hold,
			#job-grid .progress-bar .hold {
				background: #c3c;
			}

			#job-grid thead th {
				position: sticky;
				top: 0;
				background: var(--background-color);
				z-index: 10;
				border-bottom: 1px solid rgba(128, 128, 128, 0.5);
			}

			#job-grid td.completed {
				background-color: rgba(0, 170, 0, 0.1);
			}

			#job-grid td.failed {
				background-color: rgba(204, 51, 51, 0.1);
			}

			#job-grid td.pending {
				background-color: rgba(51, 204, 255, 0.1);
			}

			#job-grid td.running {
				background-color: rgba(255, 204, 0, 0.1);
			}

			#job-grid th, #job-grid td {
				vertical-align: top;
			}

			#job-grid th:empty::after {
				content: 'n/a';
				color: #ccc;
				font-weight: normal;
			}

			#job-grid tr:nth-child(even) {
				background: rgba(128, 128, 128, 0.2);
			}

			#job-grid .unavailable {
				background-image: repeating-linear-gradient(
				  45deg,
				  rgba(128, 128, 128, 0.1),
				  rgba(128, 128, 128, 0.1) 3px,
				  rgba(255, 255, 255, 0) 3px,
				  rgba(255, 255, 255, 0) 12px
				);
			}

			#job-grid .unavailable::after {
				content: 'n/a';
				color: #ccc;
				text-align: center;
			}

			#job-grid thead td:first-child {
				width: 2em;
			}

			.job-array h3 {
				font-size: inherit;
				font-weight: normal;
				margin: 0;
				position: relative;
				overflow: hidden;
				text-overflow: ellipsis;
				padding: 0 2em 4px 0;
				white-space: nowrap;
			}

			.job-array ol {
				margin: 0;
				padding: 0;
			}

			.job-array.collapsed ol {
				display: none;
			}

			.job-array .progress {
				position: absolute;
				top: 0;
				right: 0;
				font-size: 0.8em;
				line-height: 1.7em;
				pointer-events: none;
			}

			.job-array .progress-bar {
				position: absolute;
				left: 0;
				right: 0;
				bottom: 0;
				height: 4px;
				font: 4px/4px sans-serif;
				background: rgba(0, 0, 0, 0.5);
				white-space: nowrap;
				overflow: hidden;
			}

			.job-array .progress-bar > div {
				display: inline-block;
				height: 1em;
				min-width: 1em;
			}

			.job-array.completed .progress-bar {
				opacity: 0.4;
			}

			.collapsible-handle {
				cursor: pointer;
			}

			.collapsible-handle::before {
				content: '';
				display: inline-block;
				width: 0;
				border: .4em solid black;
				border-top-color: transparent;
				border-right-color: transparent;
				border-bottom-color: transparent;
				transform-origin: 0 50%;
			}

			.collapsible:not(.collapsed) .collapsible-handle::before {
				transform: rotate(90deg) translateY(-25%);
			}

			/* selected state */

			.selected {
				outline: 2px solid blue;
			}

			/* job page */

			pre .line {
				white-space: pre-wrap;
			}

			pre .marker {
				margin-right: 1em;
  			/*color: #a33;*/
			}

			pre .line[data-collapsed] {
				white-space: nowrap;
				overflow: hidden;
				display: flex;
			}

			pre .line[data-collapsed] .marker {
				flex: 0 0 200px;
				overflow: hidden;
				/* text-overflow: ellipsis; /* does not work with rtl */
				direction: rtl;
  			text-align: left;
			}

			pre .line[data-collapsed] .message {
				flex: 1 1 auto;
				white-space: pre-line;
				height: 1.2em;
				white-space: nowrap;
				text-overflow: ellipsis;
				overflow: hidden;
			}

			.page h1 small {
				padding-left: 0.5em;
				opacity: 0.5;
			}

			.page .slurm-node::before {
				content: 'on ';
			}

			.page h2 {
				position: sticky;
				top: 0;
				background-color: var(--background-color);
				margin: 0.75em 0 0 0;
				padding: 0.25em 0;
				border-bottom: 1px solid rgba(128, 128, 128, 0.5);
			}

			.page .toc {
				position: fixed;
				top: 0;
				right: 0.5em;
				z-index: 1;
			}

			.page .toc li {
				display: inline-block;
				padding: 0 0.25em;
			}

			.log-meta dt, .log-meta dd {
				display: inline-block;
				background: rgba(128, 128, 128, 0.5);
			}

			.log-meta dt {
				padding: 0 0 0 1ch;
			}

			.log-meta dt::after {
				content: ;
				content: ': ';
			}

			.log-meta dd {
				margin: 0 1ch 0 0;
				padding: 0 1ch 0 0;
			}

			.stderr .log-meta dt:not(:first-child),
			.stderr .log-meta dt:not(:first-child) + dd {
				display: none; /* hide the started/finished/average counts on the stderr output */
			}

			.stdout .duration {
				display: inline-block;
				padding: 0 1ch;
				margin: 0 1ch;
				background: rgba(128, 128, 128, 0.5);
			}

			.stdout .duration::before {
				content: 'Duration: ';
			}

			/* Highlight priority rows */

			tr.lang-cs > *,
			tr.lang-de > *,
			tr.lang-fi > *,
			tr.lang-ro > *,
			tr.lang-lv > * {
				background: rgba(0, 255, 255, 0.1);
			}

			#status-bar {
				position: fixed;
				bottom: 0;
				left: 0;
				right: 0;
				background: inherit;
				border-top: 1px solid rgba(128, 128, 128, 0.5);
				z-index: 10;
				line-height: 2em;
				padding:  0 0.25em;

				display: flex;
			}

			#status-bar .status-group {
				flex: 0 0 auto;
				display: flex;
			}

			#status-bar .spacer {
				flex: 1 1 auto;
			}

			#status-bar .status-group .status-widget {
				flex: 0 0 auto;
				margin: 0 0.25em;
				padding: 0 0.25em;
			}

			#status-bar .status-group .label {
				opacity: 0.6;
			}

			#status-bar .status-group .label::after {
				content: ': ';
			}

			#status-bar .status-group .value + .value::before {
				content: 'Â·';
				opacity: 0.6;
				margin: 0 0.5ch;
			}

			@keyframes placeHolderShimmer {
				0% {
					background-position: -500px 0
				}
				100% {
					background-position: 500px 0
				}
			}

			#status-bar .loading {
				animation-duration: 2s;
				animation-fill-mode: forwards;
				animation-iteration-count: infinite;
				animation-name: placeHolderShimmer;
				animation-timing-function: linear;
				background-image: linear-gradient(to right,
					rgba(128, 128, 128, 0.0) 0%,
					rgba(128, 128, 128, 0.1) 4%,
					rgba(128, 128, 128, 0.4) 25%,
					rgba(128, 128, 128, 0.1) 36%,
					rgba(128, 128, 128, 0.0) 50%);
				background-size: 500px 100%;
				-webkit-backface-visibility: hidden
			}

			#status-bar .loading .value {
				opacity: 0.6;
			}

			.selection-box {
				position: absolute;
				outline: 1px solid blue;
				background: rgba(0, 0, 255, 0.1);
			}
		</style>
	</head>
	<body>
		<script>
			"use strict";

			const UNSPECIFIED_LANGUAGE = Symbol('UNSPECIFIED_LANGUAGE');
			const UNSPECIFIED_COLLECTION = Symbol('UNSPECIFIED_COLLECTION');

			const COLORS = [
				'#e6194B', '#3cb44b', '#ffe119', '#4363d8', '#f58231', '#911eb4',
				'#42d4f4', '#f032e6', '#bfef45', '#fabed4', '#469990', '#dcbeff',
				'#9A6324', '#fffac8', '#800000', '#aaffc3', '#808000', '#ffd8b1',
				'#000075', '#a9a9a9', '#000000'
			];

			function identity(x) {
				return x;
			}

			/**
			 * Wrapper around an array that emits _add_ and _change_ events. The
			 * items themselves will also be event targets that emit _change_ and
			 * _delete_ events.
			 */
			class List extends EventTarget {
				constructor(keyFn) {
					super();
					this._keyFn = keyFn || identity;
					this._index = new Map();
					this._indices = [];
					this._transaction = null;
				}

				_add(item) {
					const key = this._keyFn(item);
					
					if (this._index.has(key)) {
						const current = this._index.get(key);
						assign(current, item);
						this._transaction.changed.set(key, current);
					} else {
						const current = new EventTarget();
						this._index.set(key, current);
						assign(current, item);
						this._transaction.added.set(key, current);
					}
				}

				_delete(item) {
					const key = this._keyFn(item);
					const current = this._index.get(key);

					if (current) {
						this._index.delete(key);
						this._transaction.deleted.set(key, current);
					}
				}

				_begin() {
					if (this._transaction)
						return;

					this._transaction = {
						changed: new Map(),
						added: new Map(),
						deleted: new Map()
					};
				}

				_end() {
					if (!this._transaction)
						return;

					this._indices.forEach(({index, filter}) => {
						index._begin();

						this._transaction.added.forEach(item => {
							if (filter(item)) index._add(item);
						});

						this._transaction.deleted.forEach(item => {
							index._delete(item);
						})

						this._transaction.changed.forEach(item => {
							filter(item) ? index._add(item) : index._delete(item);
						})

						index._end();
					});

					this._transaction.changed.forEach((item, key) => {
						item.dispatchEvent(new CustomEvent('change', {detail: item}));
					});

					this._transaction.deleted.forEach((item, key) => {
						item.dispatchEvent(new CustomEvent('delete', {detail: item}));
					});

					this._transaction.added.forEach((item, key) => {
						this.dispatchEvent(new CustomEvent('add', {detail: item}));
					})

					if (this._transaction.changed.size > 0 || this._transaction.added.size > 0 || this._transaction.deleted.size > 0)
						this.dispatchEvent(new CustomEvent('change'));

					this._transaction = null;
				}

				add(item) {
					this._begin();
					this._add(item);
					this._end();
				}

				delete(item) {
					this._begin();
					this._delete(item);
					this._end();
				}

				update(items) {
					this._begin();
					items.forEach(item => this._add(item));
					this._end();
				} 

				sync(items) {
					this._begin();

					const visited = new Set();
					
					items.forEach(item => {
						visited.add(this._keyFn(item));
						this._add(item);
					});

					this._index.forEach((item, key) => {
						if (!visited.has(key))
							this._delete(item);
					});

					this._end();
				}

				find(key) {
					return this._index.get(key);
				}

				forEach(fn) {
					this._index.forEach(fn);
				}

				map(fn) {
					return Array.from(this._index.values(), fn);
				}

				reduce(fn, val) {
					const it = this._index.values();
					let result = it.next();
					let i = 0;

					if (result.done)
						return val;

					if (val === undefined) {
						val = result.value;
						result = it.next();
						++i;
					}

					while (!result.done) {
						val = fn(val, result.value, i, undefined);
						result = it.next();
						++i;
					}

					return val;
				}

				get length() {
					return this._index.size;
				}

				index(filter) {
					const index = new List(this._keyFn);
					this._indices.push({filter, index});
					return index;
				}
			}

			/**
			 * Emits _start_ and _stop_ when started and stopped. Emits _trigger_
			 * when the callback function is called with the promise of the callback
			 * function.
			 */
			class Interval extends EventTarget {
				constructor(fn, interval) {
					super();
					this.fn = fn;
					this.interval = interval;
					this.timeout = null;
				}

				start() {
					clearTimeout(this.timeout);
					this.dispatchEvent(new CustomEvent('start'));
					this.timeout = setTimeout(this.trigger.bind(this), this.interval);
				}

				startImmediate() {
					clearTimeout(this.timeout);
					this.dispatchEvent(new CustomEvent('start'));
					this.timeout = setTimeout(this.trigger.bind(this), 0);
				}

				stop() {
					this.dispatchEvent(new CustomEvent('stop'));
					clearTimeout(this.timeout);
					this.timeout = null;
				}

				trigger() {
					const promise = this.fn();
					
					this.dispatchEvent(new CustomEvent('trigger', {detail: promise}));
					
					// Only schedule again if we didn't get stopped while waiting for fn.
					promise.then(() => {
						if (this.timeout !== null)
							this.start();
					});
				}
			}

			class Router {
				constructor() {
					this.routes = [];
					this.states = {};
					this.state = 0;
					this.serial = 0;

					window.addEventListener('popstate', e => {
						if (e.state in this.states)
							this.setState(e.state);
						else
							this.dispatchInternal(document.location.hash);
					});
				}

				add(pattern, callback) {
					this.routes.push({pattern, callback})
				}

				async dispatchInternal(url) {
					// Convert hash based routing in path based routing.
					if (url.startsWith('#'))
						url = url.slice(1);

					if (!url.startsWith('/'))
						url = '/' + url;

					const found = first(this.routes, route => {
						const match = url.match(route.pattern);
						if (match)
							return {route, match};
					});

					if (!found)
						throw Error(`No route for "${url}"`);
					
					const {route, match} = found;
					const state = ++this.serial;
					const page = h('div', {className: 'page'}, []);

					// Fill the page (or hopefully just async start filling it)
					const rv = route.callback(page, {url, match, ...match.groups});

					// Make page visible
					this.states[state] = page;
					this.setState(state);

					// Return possibly the promise of the page callback
					return rv;
				}

				async dispatch(url) {
					const rv = this.dispatchInternal(url);
					window.history.pushState(this.state, '', url);
					return rv;
				}

				setState(state) {
					this.state = state;
					this.render();

					// Clean up old entries
					Object.entries(this.states).forEach(([state, page]) => {
						if (state > this.state) {
							page.dispatchEvent(new CustomEvent('destroy'));
							delete this.states[state];
						}
					});
				}

				render() {
					Object.values(this.states).forEach(page => {
						if (page.parentNode) {
							page.parentNode.removeChild(page)
							page.dispatchEvent(new CustomEvent('hide'));
						}
					});

					if (this.state) {// prevent rendering of 0 state
						const page = this.states[this.state];
						document.body.appendChild(page);
						page.dispatchEvent(new CustomEvent('show'));
					}
				}
			}

			function first(items, fn) {
				/* Similar to Array.prototype.find, but returns return value of fn */
				for (let item of items) {
					let value = fn(item);
					if (value)
						return value;
				}
				return undefined;
			}

			function listen(event, selector, callback) {
				document.body.addEventListener(event, function(e) {
					let el = e.target;
					while(el) {
						if (el.matches(selector))
							return callback(el, e);
						el = el.parentElement;
					};
				});
			}

			function overlay() {
				const root = h('div', {'className': 'overlay'}, [
					h('button', {
						'className': 'close-button',
						'title': 'Close',
						'onclick': e => document.body.removeChild(root)
					}, ['\u00D7'])
				]);
				return document.body.appendChild(root);
			}

			function assign(obj, props) {
				Object.entries(props).forEach(([key, val]) => {
					if (typeof val === 'object' && val !== null && key in obj)
						assign(obj[key], val);
					else
						obj[key] = val;
				});
			}

			function debounce(fn) {
				let scheduled = null;

				return function debounced() {
				
					// If we haven't scheduled the call yet, do so.
					if (!scheduled) {
						scheduled = {
							promise: new Promise((accept, reject) => {
								setTimeout(() => {
									try {
										accept(fn.apply(undefined, scheduled.args));
									} catch (e) {
										reject(e);
									} finally {
										scheduled = null;
									}
								});
							}),
							args: Array.from(arguments)
						};
					} else {
						// Update the args for the call to the last call to the debounced function
						scheduled.args = Array.from(arguments);
					}

					return scheduled.promise;
				}
			}

			function h(name, options, children) {
				const el = document.createElement(name);
				
				if (options)
					assign(el, options);
				
				if (children)
					children.forEach(child => {
						if (!(child instanceof HTMLElement))
							child = document.createTextNode(child);
						el.appendChild(child);
					});

				return el;
			}

			async function fetchJSON(url, options) {
				const response = await fetch(url, options);
				return await response.json();
			}

			/**
			 * fetch() as an async generator, yielding chunks of content as they come in
			 */
			function stream(url) {
				const abort = new AbortController();

				return {
					async *[Symbol.asyncIterator]() {
						const decoder = new TextDecoder("utf-8");

						const response = await fetch(url, {signal: abort.signal});
						const reader = response.body.getReader();
						
						while (true) {
							const {done, value} = await reader.read();

							if (done)
								break;
							
							yield decoder.decode(value);
						}
					},
					abort() {
						abort.abort();
					}
				}
			}

			/**
			 * Generator that wraps another async iterator and yield lines (instead
			 * of chunks as stream() does)
			 */
			async function* lines(generator) {
				const iterator = generator[Symbol.asyncIterator]();
				let buffer = '';

				while (true) {
					const pos = buffer.indexOf('\n');

					// We have a full line in the buffer
					if (pos >= 0) {
						const value = buffer.substr(0, pos);
						buffer = buffer.substr(pos+1);
						yield value;
						continue;
					}

					// We still have data to read?
					const {done, value} = await iterator.next();

					// Yes! Fill buffer and start over
					if (!done) {
						buffer += value; // and we use the value next iteration
						continue;
					}

					// Nope, we're out of data. Yield remaining buffer as a last line.
					if (buffer)
						yield buffer;

					break;
				}
			}

			function streamToElement(url, root) {
				root.innerHTML = ''; // clear

				const markers = {};

				const timings = {};

				const data = stream(url);

				const meta = {
					batches: h('dd', {}, []),
					started: h('dd', {}, []),
					ended:   h('dd', {}, []),
					average: h('dd', {}, []),
				};

				const renderMeta = debounce(() => {
					// Number of markers (batches)
					meta.batches.textContent = Object.keys(markers).length;

					// Number of jobs with timings[marker].start
					meta.started.textContent = Object.keys(timings).length;
					
					// Number of jobs with timings[marker].end
					meta.ended.textContent = Object.values(timings).filter(({end}) => end !== undefined).length;
					
					// avg(timings[marker].end - timings[marker.start])
					const avg = Object.values(timings).reduce(({sum, count}, {start, end}) => (start && end ? {sum: sum + (end - start), count: count + 1} : {sum, count}), {sum: 0, count: 0});
					meta.average.textContent = avg.count > 0 ? formatDuration(avg.sum / avg.count) : '';
				});
				
				async function render() {
					try {
						for await (let line of lines(data)) {
							// Test if line is in the GNU parallel output format of "[args] message"
							const match = line.match(/^(\[.+?\]|\d+)\t(.+?)$/);
							if (match) {
								const [ , marker, message] = match;
								let messageNodes = [message];

								// If this is the first message for this set of args, assign a colour
								if (!(marker in markers))
									markers[marker] = Object.keys(markers).length;
								const color = COLORS[markers[marker] % COLORS.length];

								// If the message part is a typical start or finish message, safe that info
								const timingMatch = message.match(/^(start|finish) (\d{4}-\d{2}-\d{2}) (\d{2}:\d{2}:\d{2})$/)
								if (timingMatch) {
									try {
										const [, op, date, time] = timingMatch;
										const dt = Date.parse(`${date}T${time}.000Z`) // Parses as ISO 8601 format;
										switch (op) {
											case 'start':
												timings[marker] = {start:dt};
												break;
											case 'finish':
												timings[marker].end = dt;
												messageNodes.push(h('span', {className: 'duration'}, [formatDuration(timings[marker])]));
												break;
										}
									} catch (e) {
										console.log('Error while parsing', message, e);
										// too bad but no harm done
									}
								}

								root.appendChild(h('div', {className: 'line', dataset: {collapsible: true, collapsed: true}}, [
									h('span', {'className': 'marker', style: {color}}, [match[1]]),
									h('span', {'className': 'message'}, messageNodes)
								]));
							} else {
								root.appendChild(h('div', {className: 'line'}, [line]));
							}

							renderMeta();
						}
					} catch (e) {
						if (e.name !== 'AbortError')
							throw e;
					}
				};

				root.appendChild(h('dl', {'className': 'log-meta'}, [
					h('dt', {}, ['Batches']),
					meta.batches,
					h('dt', {}, ['Started']),
					meta.started,
					h('dt', {}, ['Finished']),
					meta.ended,
					h('dt', {}, ['Average']),
					meta.average
				]));

				render(); // Just let it go! Async and not awaited here, so will go on for a while

				renderMeta(); // Also render the meta info at least once

				return data.abort; // Return the stop function
			}

			function renderGrid(table, collections) {
				const SPANISH_COOFFICIAL_LANGUAGES = ['ca', 'eu', 'oc', 'gl'];
				const languages = Array.from(collections.reduce((languages, collection) => {
					collection.languages.forEach(language => languages.add(language))
					return languages
				}, new Set())).sort((a, b) => {
					if (SPANISH_COOFFICIAL_LANGUAGES.includes(a) ^ SPANISH_COOFFICIAL_LANGUAGES.includes(b))
						return SPANISH_COOFFICIAL_LANGUAGES.includes(a) ? -1 : 1;
					else
						return a < b ? -1 : 1;
				});

				// Add the non-language-specific jobs at the end
				languages.push(UNSPECIFIED_LANGUAGE);

				collections = [
					...collections,
					{
						name: UNSPECIFIED_COLLECTION,
						languages: Array.from(languages)
					}
				];

				table.appendChild(h('thead', {}, [
					h('tr', {}, [
						h('td'),
						...collections.map(collection => h('th', {}, [
							collection.name !== UNSPECIFIED_COLLECTION ? collection.name : ''
						]))
					])
				]));

				const grid = Object.fromEntries(collections.map(collection => [collection.name, {}]));

				function updateGridCell() {
					// Pending or running depends on any job in the job array
					this.classList.toggle('pending', this.querySelector('.job-array.pending'));
					this.classList.toggle('running', this.querySelector('.job-array.running'));

					// Completed or failed only on the last one
					this.classList.toggle('failed', this.querySelector('.job-array:last-child.failed'));
					this.classList.toggle('completed', this.querySelector('.job-array:last-child.completed'));
				}

				table.appendChild(h('tbody', {},
					languages.map(language => h('tr', language !== UNSPECIFIED_LANGUAGE ? {className: `lang-${language}`} : {}, [
						h('th', {}, [language !== UNSPECIFIED_LANGUAGE ? language : '']),
						...collections.map(collection => {
							const td = h('td', {}, []);
							if (!collection.languages.includes(language) && language !== UNSPECIFIED_LANGUAGE)
								td.classList.add('unavailable');
							grid[collection.name][language] = {td, update: debounce(updateGridCell.bind(td))}
							return td;
						})
					]))
				));

				return grid;
			}

			function formatJob(job) {
				if ('ArrayJobId' in job.slurm && 'ArrayTaskId' in job.slurm)
					return `${job.slurm['ArrayJobId']}_${job.slurm['ArrayTaskId']}`;
				else
					return job.slurm['JobId'];
			}

			function formatJobArray(job) {
				const match = job.slurm['JobName'].match(/(warc2text|pdf2warc|reduce-tmx|reduce-tmx-deferred|reduce-classified|reduce-filtered|shard|merge-shard|clean-shard|dedupe|split|translate|tokenise|align|fix|score|clean)-/)
				return match && match[1] || job.slurm['JobName']
			}

			function formatPercentage(cnt, sum) {
				const frac = sum > 0 ? cnt / sum : 0;
				return Math.floor((frac * 10000.0) / 100.0).toFixed(1) + '%';
			}

			function formatDuration(dt) {
				if (typeof dt !== 'number')
					dt = dt.end - dt.start;
				const hours =   Math.floor((dt / 3600_000));
				const minutes = Math.floor((dt /   60_000) % 60);
				const seconds = Math.floor((dt /    1_000) % 60);
				return `${hours.toFixed()}:${minutes.toFixed().padStart(2, '0')}:${seconds.toFixed().padStart(2, '0')}`;
			}

			function addJobSection(cell, job) {
				const list = h('ol', {}, []);
				const progress = h('span', {className: 'progress'});
				const bar = h('div', {className: 'progress-bar'}, [
					h('div', { className: 'failed',    title: 'Failed' }),
					h('div', { className: 'completed', title: 'Completed' }),
					h('div', { className: 'running',   title: 'Running' }),
					h('div', { className: 'pending',   title: 'Pending' }),
					h('div', { className: 'hold',      title: 'Hold' }),
					h('div', { className: 'cancelled', title: 'Cancelled'}),
				]);

				cell.td.appendChild(h('div', {className: 'job-array collapsible collapsed'}, [
					h('h3', {className: 'collapsible-handle'}, [
						formatJobArray(job),
						progress, bar,
					]),
					list
				]));

				list.update = debounce(() => {
					const counts = {
						'job': 0,
						'pending': 0,
						'hold': 0,
						'running': 0,
						'completed': 0,
						'cancelled': 0,
						'failed': 0,
						'selected': 0
					};

					list.querySelectorAll('.job').forEach(el => {
						Object.keys(counts).forEach(className => {
							if (el.classList.contains(className))
								counts[className] += 1; 
						})
					});

					// Update each bar (if there is a bar for said class)
					Object.keys(counts).forEach(className => {
						const bar = list.parentNode.querySelector(`.progress-bar .${className}`);
						if (bar) {
							bar.style.width = formatPercentage(counts[className], counts['job']);
							bar.hidden = counts[className] == 0;
						}
					});

					// Mark the whole list as running if there is something running
					list.parentNode.classList.toggle('pending', counts['pending'] > 0);
					list.parentNode.classList.toggle('running', counts['running'] > 0);
					list.parentNode.classList.toggle('failed', counts['failed'] > 0);
					
					// Mark the whole list as completed if *all* jobs are completed
					list.parentNode.classList.toggle('completed', counts['completed'] == counts['job']);

					// Update the little progress indicator text
					progress.textContent = `${counts['running']}/${counts['job']}`;

					// Update selected status if *all* jobs are selected
					list.parentNode.classList.toggle('selected', counts['selected'] === counts['job']);

					cell.update();
				});

				return list;
			}

			function addJobToGrid(grid, job) {
				const id = job.slurm['ArrayJobId'] || job.slurm['JobId'];

				const cell = grid[job.collection || UNSPECIFIED_COLLECTION][job.language || UNSPECIFIED_LANGUAGE];

				if (!cell) {
					console.warn("No cell for ", job.collection, job.language);
					return;
				}

				if (!('lists' in cell))
					cell.lists = {};

				if (!(id in cell.lists))
					cell.lists[id] = addJobSection(cell, job);

				const list = cell.lists[id];
				const link = list.appendChild(h('a',
					{className: 'job', href: '#' + job.link},
					[formatJob(job)]));

				const render = () => {
					link.title = `Elapsed: ${job.slurm['Elapsed']}`;

					link.classList.toggle('pending',   'State' in job.slurm && job.slurm['State'] == 'PENDING' && job.slurm['Reason'] != 'JobHeldUser');
					link.classList.toggle('hold',      'State' in job.slurm && job.slurm['State'] == 'PENDING' && job.slurm['Reason'] == 'JobHeldUser');
					link.classList.toggle('running',   'State' in job.slurm && job.slurm['State'] == 'RUNNING');
					link.classList.toggle('completed', 'State' in job.slurm && job.slurm['State'] == 'COMPLETED');
					link.classList.toggle('cancelled', 'State' in job.slurm && job.slurm['State'].match(/^CANCELLED/));
					link.classList.toggle('failed',    'State' in job.slurm && job.slurm['State'].match(/^TIMEOUT|FAILED|OUT_OF_MEMORY$/));
					link.classList.toggle('selected',  job.selected === true);
					list.update(); // Update list running status
				};

				render();

				job.addEventListener('change', render);

				job.addEventListener('delete', () => {
					link.parentNode.removeChild(link)
				}, {once: true});
			}

			function formatFileSize(filesize, unit) {
				const units = ['B', 'KB', 'MB', 'GB', 'TB', 'PB'];
				let current = unit ? units.indexOf(unit) : 0;
				while (filesize > 1000 && current < units.length) {
					filesize /= 1000;
					current += 1;
				}
				return `${filesize.toFixed(1)} ${units[current]}`;
			}

			const CAPITALIZED = {
				'cpus': 'CPUs',
				'gpus': 'GPUs',
			};

			function capitalize(str) {
				if (str in CAPITALIZED)
					return CAPITALIZED[str];

				return str.split(' ').map(word => word.substr(0, 1).toUpperCase() + word.substr(1)).join(' ');
			}

			function tryParseInt(str, fallback, pattern) {
				let int = NaN;

				if (typeof str === 'number') {
					int = str;
				} else if (typeof str == 'string') {
					if (pattern) {
						const match = str.match(pattern)
						if (match === null)
							return fallback
						str = match[1];
					}
					int = parseInt(str, 10);
				}

				return isNaN(int) ? fallback : int;	
			}

			function listenToLoadingStatus(interval, el) {
				interval.addEventListener('trigger', async ({detail}) => {
					el.classList.toggle('loading', true)
					try {
						await detail;
					} finally {
						el.classList.toggle('loading', false);
					}
				});
			}

			function updateJobCounts(root, index) {
				const counts = {
					selected: 0,
					pending: 0,
					hold: 0,
					running: 0,
					completed: 0,
					cancelled: 0,
					timeout: 0,
					failed: 0,
					out_of_memory: 0,
					cores: 0,
					gpus: 0
				};

				index.forEach(job => {
					if ('State' in job.slurm) {
						counts['selected']      += 1;
						counts['pending']       += 'State' in job.slurm && job.slurm['State'] == 'PENDING' && job.slurm['Reason'] != 'JobHeldUser' ? 1 : 0;
						counts['hold']          += 'State' in job.slurm && job.slurm['State'] == 'PENDING' && job.slurm['Reason'] == 'JobHeldUser' ? 1 : 0;
						counts['running']       += 'State' in job.slurm && job.slurm['State'] == 'RUNNING' ? 1 : 0;
						counts['completed']     += 'State' in job.slurm && job.slurm['State'] == 'COMPLETED' ? 1 : 0;
						counts['timeout']       += 'State' in job.slurm && job.slurm['State'] == 'TIMEOUT' ? 1 : 0;
						counts['failed']        += 'State' in job.slurm && job.slurm['State'] == 'FAILED' ? 1 : 0;
						counts['out_of_memory'] += 'State' in job.slurm && job.slurm['State'] == 'OUT_OF_MEMORY' ? 1 : 0;
						counts['cancelled']     += 'State' in job.slurm && job.slurm['State'].startsWith('CANCELLED') ? 1 : 0;
						counts['cores']         += 'State' in job.slurm && job.slurm['State'] == 'RUNNING' ? tryParseInt(job.slurm['AllocCPUS'], 0) : 0;
						counts['gpus']					+= 'State' in job.slurm && job.slurm['State'] == 'RUNNING' ? tryParseInt(job.slurm['AllocGRES'], 0, /gpu:(\d+)/) : 0;
					}
				});

				root.querySelectorAll('.status-widget').forEach(el => {
					const state = el.dataset.state;
					if (state in counts) {
						el.hidden = counts[state] === 0;
						el.querySelector('.count').textContent = counts[state].toString();
					}
				});
			}

			const router = new Router();

			const index = new List(job => job.id);

			const selection = index.index(job => job.selected === true);

			let lastUpdate = '';
			
			// After that prefer just the queue updates
			const updater = new Interval(async () => {
				const delta = await fetchJSON(lastUpdate ? '/jobs/delta/' + lastUpdate : '/jobs/');
				index.update(delta.jobs);
				lastUpdate = delta.timestamp;
			}, 60 * 1000);

			const jobStatusBar = h('div', {'id': 'job-status', 'className': 'status-group'},
				['pending', 'hold', 'running', 'cores', 'gpus'].map(state => {
					return h('div', {'className': 'status-widget', 'dataset': {state}}, [
						h('span', {'className': 'label state'}, [capitalize(state)]),
						h('span', {'className': 'value count'}, ['0'])
					]);
				}));

			listenToLoadingStatus(updater, jobStatusBar);

			index.addEventListener('change', updateJobCounts.bind(null, jobStatusBar, index));

			jobStatusBar.addEventListener('click', () => updater.startImmediate());

			const selectionStatusBar = h('div', {'id': 'selection-status', 'className': 'status-group', 'hidden': true}, [
				...['selected', 'pending', 'hold', 'running', 'completed', 'timeout', 'failed', 'cancelled', 'cores', 'gpus'].map(state => {
					return h('div', {'className': 'status-widget', 'dataset': {state}}, [
						h('span', {'className': 'label state'}, [capitalize(state)]),
						h('span', {'className': 'value count'}, ['0'])
					])
				}),
				h('div', {'className': 'status-widget'}, [
					h('span', {'className': 'label'}, ['Core hours used']),
					h('span', {'className': 'value used core-hours'}, ['0'])
				]),
				h('div', {'className': 'status-widget'}, [
					h('span', {'className': 'label'}, ['GPU hours used']),
					h('span', {'className': 'value used gpu-hours'}, ['0'])
				])
			]);

			const coreHoursFormat = new Intl.NumberFormat(undefined, {
				style: 'unit',
				unit: 'hour',
				maximumFractionDigits: 0
			});

			selection.addEventListener('change', e => {
				updateJobCounts(selectionStatusBar, selection);

				const seconds = selection.reduce((acc, job) => acc + parseInt(job.slurm['CPUTimeRAW'] || '0'), 0);
				selectionStatusBar.querySelector('.value.used.core-hours').textContent = coreHoursFormat.format(seconds / 3600);

				const gpuSeconds = selection.reduce((acc, job) => acc + parseInt(job.slurm['ElapsedRaw'] || '0') * tryParseInt(job.slurm['AllocGRES'], 0, /gpu:(\d+)/), 0);
				selectionStatusBar.querySelector('.value.used.gpu-hours').textContent = coreHoursFormat.format(gpuSeconds / 3600);				

				selectionStatusBar.hidden = selection.length == 0;
				jobStatusBar.hidden = selection.length != 0;
			});

			const accountStatusBar = h('div', {'id': 'account-status', 'className': 'status-group'}, [
				h('div', {'className': 'status-widget'}, [
						h('span', {'className': 'label'}, ['Remaining Core hours']),
						h('span', {'className': 'value remaining core-hours', 'dataset': {'type': '-cpu'}})
				]),
				h('div', {'className': 'status-widget'}, [
						h('span', {'className': 'label'}, ['GPU hours']),
						h('span', {'className': 'value remaining core-hours', 'dataset': {'type': '-gpu'}})
				])
			]);

			const accountUpdater = new Interval(async () => {
				const balance = await fetchJSON('/balance/');
				accountStatusBar.querySelectorAll('.remaining.core-hours').forEach(el => {
					const account = balance.find(account => account.account.toLowerCase().endsWith(el.dataset.type));
					el.textContent = account ? coreHoursFormat.format(account.balance) : '';
				});
			}, 30 * 60 * 1000);
			listenToLoadingStatus(accountUpdater, accountStatusBar);
			accountUpdater.startImmediate();
			accountStatusBar.addEventListener('click', () => accountUpdater.startImmediate());

			const diskStatusBarWidgetTemplate = h('span', {'className': 'value remaining size'}, ['0']);

			const diskStatusBar = h('div', {'id': 'disk-status', 'className': 'status-group'}, [
					h('div', {'className': 'status-widget'}, [
						h('span', {'className': 'label'}, ['Disk space remaining']),
					])
				]);

			document.body.appendChild(h('div', {'id': 'status-bar'}, [
				jobStatusBar,
				selectionStatusBar,
				h('div', {'className': 'spacer'}),
				accountStatusBar,
				diskStatusBar
			]));

			const diskUsageUpdater = new Interval(async () => {
				const quota = await fetchJSON('/quota/');
				quota.forEach(entry => {
					let el = diskStatusBar.querySelector(`.value[data-proj=${entry['proj']}]`);
					if (!el) {
						el = diskStatusBarWidgetTemplate.cloneNode(true);
						el.dataset.proj = entry['proj']
						diskStatusBar.querySelector('.status-widget').appendChild(el);
					}
					el.title = `Disk quota for ${entry['proj']}: ${formatFileSize(entry['size_usage'], 'GB')}/${formatFileSize(entry['size_quota'], 'GB')}`;
					el.textContent = formatFileSize(entry['size_quota'] - entry['size_usage'], 'GB');
				});
			}, 5 * 60 * 1000);

			listenToLoadingStatus(diskUsageUpdater, diskStatusBar);
			diskUsageUpdater.startImmediate();
			diskStatusBar.addEventListener('click', () => diskUsageUpdater.startImmediate());

			router.add(/^\/$/, async (root) => {
				const collections = await fetchJSON('/collections/');
				collections.sort((left, right) => left.name.localeCompare(right.name));

				const table = h('table', {'id': 'job-grid'});
				root.appendChild(table);

				const grid = renderGrid(table, collections);
				index.forEach(job => addJobToGrid(grid, job))
				
				// When new jobs are found, add them
				const addJob = e => addJobToGrid(grid, e.detail);
				index.addEventListener('add', addJob);

				// Stop listening for new jobs when this page gets scrapped
				root.addEventListener('destroy', e => {
					index.removeEventListener('add', addJob);
				}, {once: true});
			});

			router.add(/^\/jobs\/(?<job_id>\d+(_\d+)?)\/$/, (root, {url, job_id}) => {
				// Make sure the job exists in some form so we have something to update
				index.add({id: job_id, slurm: {}});

				const job = index.find(job_id)

				// Fetch more details about this job in the background
				fetch(url)
					.then(response => response.json())
					.then(job => index.add(job));

				const slurmNodeLabel = h('small', {className: 'slurm-node'});

				root.appendChild(h('h1', {}, [job_id, slurmNodeLabel]));

				function live(el, render) {
					root.addEventListener('show', e => {
						const stop = render(el);
						root.addEventListener('hide', stop, {once: true});
					});
					return el;
				}

				root.appendChild(h('ol', {className: 'toc'}, [
					['StdOut', `#${job_id}-stdout`],
					['StdErr', `#${job_id}-stderr`],
					['Properties', `#${job_id}-props`]
				].map(([label, href]) => h('li', {}, [h('a', {href}, [label])]))));

				root.appendChild(h('section', {id: `${job_id}-stdout`, className: 'stdout'}, [
					h('h2', {}, ['StdOut']),
					live(h('pre'), el => streamToElement(`/jobs/${job_id}/stdout`, el))
				]));

				root.appendChild(h('section', {id: `${job_id}-stderr`, className: 'stderr'}, [
					h('h2', {}, ['StdErr']),
					live(h('pre'), el => streamToElement(`/jobs/${job_id}/stderr`, el))
				]));

				function render(el) {
					function update({detail}) {
						const updated = h('dl', {}, Object.entries(detail.slurm || {}).map(([key, value]) => {
							return [
								h('dt', {}, [key]),
								h('dd', {}, [value])
							];
						}).flat(1));
						el.parentNode.replaceChild(updated, el);
						el = updated;

						if ('NODELIST' in detail.slurm)
							slurmNodeLabel.textContent = detail.slurm['NODELIST'];
					}

					// Update now (and every time this page becomes visible)
					update({detail:job});

					// Update every time the job changes
					job.addEventListener('change', update);

					// but stop updating once this page is no longer visible.
					return () => root.removeEventListener('change', update);
				}

				root.appendChild(h('section', {id: `${job_id}-props`, className: 'props'}, [
					h('h2', {}, ['Properties']),
					live(h('dl'), render)
				]));
			})

			listen('click', 'a.job', async (el, e) => {
				if (e.metaKey)
					return;

				try {
					router.dispatch(el.hash);
					e.preventDefault();
				} catch (err) {
					console.error(err);
				}
			});

			function findParent(el, selector) {
				while (el && !el.matches(selector))
					el = el.parentNode;
				return el;
			}

			// the collapsible lists
			listen('click', '.collapsible .collapsible-handle', (el, e) => {
				if (e.metaKey)
					return;

				findParent(el, '.collapsible').classList.toggle('collapsed');
				e.preventDefault();
			});

			// the collapsed rows in the log: only collapse/contract when cicking,
			// not when selecting text. (better ui would be a button, but that
			// button would probably be small.)
			listen('mousedown', '[data-collapsible]', (el, e) => {
				let moved = false;

				el.addEventListener('mousemove', e => {
					moved = true;
				}, {once: true});

				el.addEventListener('mouseup', e => {
					if (!moved) {
						if (el.dataset.collapsed)
							delete el.dataset.collapsed;
						else
							el.dataset.collapsed = 'true';
					}
				}, {once: true});
			});

			function getJobsByElement(el) {
				if (el.matches('.job'))
					return [index.find(el.textContent)];

				if (el.matches('.job-array h3, .job-array h3 *'))
					return Array.from(findParent(el, '.job-array').querySelectorAll('.job'), jobEl => index.find(jobEl.textContent));
					
				throw new Error(`Can't identify jobs from element ${el}`);
			}

			function selectJobByElement(el, toggle) {
				const jobs = getJobsByElement(el);
				const change = {selected: toggle === undefined ? (jobs.every(job => job.selected) ? false : true) : toggle};
				index.update(jobs.map(job => ({id: job.id, ...change})));
			}

			// Toggle selection whole job array
			listen('click', '#job-grid', (el, e) => {
				// Did we click on a selectable thing?
				if (e.target.matches('.job, .job-array h3, .job-array h3 *')) {
					if (e.metaKey) {
						selectJobByElement(e.target);
						e.preventDefault();
					}
				} else {
					// Deselect all
					index.update(index.map(job => ({id: job.id, selected: false})));
				}
			});

			function getBoundingRect(el) {
				const rect = el.getBoundingClientRect();
				return {
					x: window.scrollX + rect.x,
					y: window.scrollY + rect.y,
					width: rect.right - rect.left,
					height: rect.bottom - rect.top
				};
			}

			function intersects(a, b) {
				return !(
					a.x + a.width < b.x || 
					a.x > b.x + b.width ||
					a.y + a.height < b.y ||
					a.y > b.y + b.height
				);
			}

			function diff(a, b) {
				// use array because Set does not have map()
				const difference = [];

				for (let key of a)
					if (!b.has(key))
						difference.push(key)

				return difference;
			}

			// Drag & select
			listen('mousedown', '#job-grid', (el, e) => {
				// Only act on primary button (not context menu or navigation)
				if (e.button != 0)
					return;

				// Prevent text selection
				e.preventDefault();

				let box = h('div', {'className': 'selection-box'});
				let start = {
					x: window.scrollX + e.clientX,
					y: window.scrollY + e.clientY
				};

				const selectables = Array.from(
					document.querySelectorAll('.job, .job-array h3'),
					el => ({el, rect: getBoundingRect(el) }))
					.filter(({rect}) => rect.width > 0 && rect.height > 0);

				let selected = new Set(e.metaKey ? [] : selection.map(job => job.id));

				function move(e) {
					e.preventDefault();

					// Drawn rect
					const rect = {
						x:      Math.min(window.scrollX + e.clientX, start.x),
						y:      Math.min(window.scrollY + e.clientY, start.y),
						width:  Math.abs(window.scrollX + e.clientX - start.x),
						height: Math.abs(window.scrollY + e.clientY - start.y)
					};

					// If we're fresh out of mousedown
					if (!box.parentNode) {
						// and haven't moved a lot yet, just ignore the movement.
						if (rect.width < 5 && rect.height < 5)
							return;

						// Otherwise, start drawing the box. No way back to onclick now!
						document.body.append(box);
					}

					// Update visual rect
					box.style.left   = `${rect.x}px`;
					box.style.top    = `${rect.y}px`;
					box.style.width  = `${rect.width}px`;
					box.style.height = `${rect.height}px`;

					// Figure out jobs that intersect rect
					const jobs = new Set(selectables
						.filter(selectable => intersects(selectable.rect, rect))
						.reduce((acc, selectable) => acc.concat(getJobsByElement(selectable.el)), [])
						.map(job => job.id));

					// Update current selection
					index.update([
						...diff(selected, jobs).map(id => ({id, selected: false})),
						...diff(jobs, selected).map(id => ({id, selected: true}))
					]);

					selected = jobs;
				}

				document.addEventListener('mousemove', move);
				document.addEventListener('mouseup', e => {
					document.removeEventListener('mousemove', move);
					if (box.parentNode) {
						// Prevent selecting text
						e.preventDefault();

						// Prevent next onclick
						document.addEventListener('click',
							e => e.stopPropagation(),
							{capture: true, once: true});
						
						document.body.removeChild(box);
					}
				}, {once: true});
			})

			updater.startImmediate();

			router.dispatch(document.location.hash);
		</script>
	</body>
</html>
